[
    {
        "name": "Week - 5: Single Linked List",
        "questions": [
            {
                "id": "w5-sll-001",
                "question_text": "Comprehensive Single Linked List Operations",
                "question_description": "In this foundational exercise, you must implement a Singly Linked List using dynamic memory allocation (e.g., malloc). You are required to support basic setup, traversal (display and count), searching, and diverse insertions and deletions. Handle boundary cases precisely, such as attempting to delete from an empty list or searching for a non-existent element.",
                "input_format": "An integer N (number of operations), followed by N lines of commands:\n1. 'ins_beg X': Insert X at beginning.\n2. 'ins_end X': Insert X at end.\n3. 'ins_pos P X': Insert X at position P (1-based).\n4. 'del_beg': Delete from beginning.\n5. 'del_end': Delete from end.\n6. 'del_pos P': Delete node at position P.\n7. 'del_key X': Delete first occurrence of value X.\n8. 'display': Print all elements.\n9. 'count': Print the number of nodes.\n10. 'search X': Find element X.",
                "output_format": "For deletions, print 'Underflow' if empty, or 'Not Found' if key doesn't exist. For 'search', print 'Found at P' or 'Not Found'. For 'display', print space-separated elements or 'Empty'.",
                "constraints": "1 <= N <= 1000. Use dynamic memory for nodes.",
                "hints": "Maintain a 'head' pointer. For pos-based operations, iterate using a temporary pointer until pos-1. Be careful of edge cases like deleting the head node or appending to an empty list.",
                "question_type": "CODING",
                "difficulty": "MEDIUM",
                "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\ntypedef struct Node { int d; struct Node* n; } Node;\nNode* head = NULL;\nvoid ib(int v) { Node* nn = malloc(sizeof(Node)); nn->d=v; nn->n=head; head=nn; }\nvoid ie(int v) { Node* nn = malloc(sizeof(Node)); nn->d=v; nn->n=NULL; if(!head) head=nn; else { Node* t=head; while(t->n) t=t->n; t->n=nn; } }\nvoid ip(int p, int v) { if(p==1) ib(v); else { Node* t=head; for(int i=1; i<p-1 && t; i++) t=t->n; if(t) { Node* nn=malloc(sizeof(Node)); nn->d=v; nn->n=t->n; t->n=nn; } } }\nvoid db() { if(head) { Node* t=head; head=head->n; free(t); } else printf(\"Underflow\\n\"); }\nvoid de() { if(!head) printf(\"Underflow\\n\"); else if(!head->n) { free(head); head=NULL; } else { Node* t=head; while(t->n->n) t=t->n; free(t->n); t->n=NULL; } }\nvoid dp(int p) { if(!head) printf(\"Underflow\\n\"); else if(p==1) db(); else { Node* t=head; for(int i=1; i<p-1 && t->n; i++) t=t->n; if(t->n) { Node* tmp=t->n; t->n=tmp->n; free(tmp); } } }\nvoid dk(int v) { if(!head) printf(\"Underflow\\n\"); else if(head->d==v) db(); else { Node* t=head; while(t->n && t->n->d!=v) t=t->n; if(t->n) { Node* tmp=t->n; t->n=tmp->n; free(tmp); } else printf(\"Not Found\\n\"); } }\nvoid disp() { if(!head) printf(\"Empty\\n\"); else { Node* t=head; while(t) { printf(\"%d%c\", t->d, t->n?' ':'\\n'); t=t->n; } } }\nvoid cnt() { int c=0; Node* t=head; while(t) { c++; t=t->n; } printf(\"%d\\n\", c); }\nvoid sch(int v) { int p=1; Node* t=head; while(t) { if(t->d==v) { printf(\"Found at %d\\n\", p); return; } p++; t=t->n; } printf(\"Not Found\\n\"); }\nint main() {\n    int n, v, p; char op[15];\n    if(scanf(\"%d\", &n) != 1) return 0;\n    while(n--) {\n        scanf(\"%s\", op);\n        if(!strcmp(op, \"ins_beg\")) { scanf(\"%d\", &v); ib(v); }\n        else if(!strcmp(op, \"ins_end\")) { scanf(\"%d\", &v); ie(v); }\n        else if(!strcmp(op, \"ins_pos\")) { scanf(\"%d %d\", &p, &v); ip(p, v); }\n        else if(!strcmp(op, \"del_beg\")) db();\n        else if(!strcmp(op, \"del_end\")) de();\n        else if(!strcmp(op, \"del_pos\")) { scanf(\"%d\", &p); dp(p); }\n        else if(!strcmp(op, \"del_key\")) { scanf(\"%d\", &v); dk(v); }\n        else if(!strcmp(op, \"display\")) disp();\n        else if(!strcmp(op, \"count\")) cnt();\n        else if(!strcmp(op, \"search\")) { scanf(\"%d\", &v); sch(v); }\n    }\n    return 0;\n}",
                "test_cases": [
                    {
                        "input": "8\nins_end 10\nins_beg 5\nins_end 20\ncount\ndisplay\nsearch 10\ndel_pos 2\ndisplay",
                        "expectedOutput": "3\n5 10 20\nFound at 2\n5 20"
                    },
                    {
                        "input": "4\ndisplay\ndel_beg\ndel_end\ndel_key 10",
                        "expectedOutput": "Empty\nUnderflow\nUnderflow\nUnderflow"
                    },
                    {
                        "input": "5\nins_end 1\nins_end 2\nins_end 3\ndel_key 4\ndisplay",
                        "expectedOutput": "Not Found\n1 2 3"
                    },
                    {
                        "input": "5\nins_beg 100\nins_pos 2 200\nins_pos 1 50\ndisplay\ncount",
                        "expectedOutput": "50 100 200\n3"
                    },
                    {
                        "input": "5\nins_beg 7\ndel_end\nsearch 7\ncount\ndisplay",
                        "expectedOutput": "Not Found\n0\nEmpty"
                    },
                    {
                        "input": "4\nins_end 20\ndel_pos 1\ndisplay\ndel_pos 1",
                        "expectedOutput": "Empty\nUnderflow"
                    },
                    {
                        "input": "6\nins_end 5\nins_end 5\nins_end 5\ndel_key 5\ncount\ndisplay",
                        "expectedOutput": "2\n5 5"
                    },
                    {
                        "input": "3\nins_end 99\nsearch 99\nsearch 100",
                        "expectedOutput": "Found at 1\nNot Found"
                    },
                    {
                        "input": "7\nins_end 10\nins_end 20\nins_end 30\ndel_pos 2\ndisplay\ndel_pos 2\ndisplay",
                        "expectedOutput": "10 30\n10"
                    },
                    {
                        "input": "3\nins_beg 50\ndel_key 50\ndisplay",
                        "expectedOutput": "Empty"
                    }
                ],
                "solution_explanation": "This monolithic template covers all core edge cases for Singly Linked Lists, validating operations like searching through empty lists, unlinked insertions using safe loops, and checking node connections dynamically to prevent segmentation faults.",
                "language": "C"
            },
            {
                "id": "w5-sll-002",
                "question_text": "Reverse a Linked List and Find Middle Element",
                "question_description": "A secure protocol dictates that messages stored sequentially in nodes must be read backwards to decode them, while finding the 'key' which is exactly the middle element. Construct a singly linked list from an array of numbers, then perform an in-place pointer reversal. Furthermore, utilize the slow/fast pointer design to determine the middle node without utilizing your count traversal limit.",
                "input_format": "An integer N, followed by N space-separated numbers to be inserted at the end iteratively.",
                "output_format": "Line 1: The reversed list displayed separated by space.\nLine 2: 'Middle: X' representing the middle element value. (If N is even, take the second middle element).",
                "constraints": "1 <= N <= 1000.",
                "hints": "Reversal: Iterate strictly holding previous, current, and next pointers. For the middle element, advance one pointer by 1 step and the other by 2 steps until the fast pointer hits NULL.",
                "question_type": "CODING",
                "difficulty": "HARD",
                "answer": "#include <stdio.h>\n#include <stdlib.h>\ntypedef struct Node { int d; struct Node* n; } Node;\nint main() {\n    int k, v; if(scanf(\"%d\", &k) != 1) return 0;\n    if(k==0) { printf(\"Empty\\n\"); return 0; }\n    Node *head=NULL, *tail=NULL;\n    for(int i=0; i<k; i++) {\n        scanf(\"%d\", &v); Node* nn = malloc(sizeof(Node)); nn->d=v; nn->n=NULL;\n        if(!head) head=tail=nn; else { tail->n=nn; tail=nn; } }\n    Node *prev=NULL, *curr=head, *next=NULL;\n    while(curr) { next=curr->n; curr->n=prev; prev=curr; curr=next; }\n    head = prev;\n    Node *t=head; while(t) { printf(\"%d%c\", t->d, t->n?' ':'\\n'); t=t->n; }\n    Node *s=head, *f=head;\n    while(f && f->n) { s=s->n; f=f->n->n; }\n    printf(\"Middle: %d\\n\", s->d);\n    return 0;\n}",
                "test_cases": [
                    {
                        "input": "5\n1 2 3 4 5",
                        "expectedOutput": "5 4 3 2 1\nMiddle: 3"
                    },
                    {
                        "input": "4\n1 2 3 4",
                        "expectedOutput": "4 3 2 1\nMiddle: 2"
                    },
                    {
                        "input": "1\n99",
                        "expectedOutput": "99\nMiddle: 99"
                    },
                    {
                        "input": "6\n10 20 30 40 50 60",
                        "expectedOutput": "60 50 40 30 20 10\nMiddle: 30"
                    },
                    {
                        "input": "2\n1 2",
                        "expectedOutput": "2 1\nMiddle: 1"
                    },
                    {
                        "input": "3\n100 200 300",
                        "expectedOutput": "300 200 100\nMiddle: 200"
                    },
                    {
                        "input": "7\n7 6 5 4 3 2 1",
                        "expectedOutput": "1 2 3 4 5 6 7\nMiddle: 4"
                    },
                    {
                        "input": "0",
                        "expectedOutput": "Empty"
                    }
                ],
                "solution_explanation": "List reversal in-place swaps link pointers directly rather than creating new nodes. Identifying the middle uses the tortoise and hare approach, guaranteeing exactly O(N) evaluation time dynamically.",
                "language": "C"
            },
            {
                "id": "w5-sll-003",
                "question_text": "Merge Two Sorted Linked Lists & Sort Strategy",
                "question_description": "Data processing pipelines often receive sorted fragmented sequences. You are required to merge two predefined sorted singly linked lists into a single consolidated, sorted linked list efficiently. This must be achieved by modifying the pointers of the existing lists rather than dynamically allocating new structural elements. Also assume lists are pre-sorted.",
                "input_format": "Integer N (size of List 1) and N integers. Then Integer M (size of List 2) and M integers.",
                "output_format": "The seamlessly merged sorted list elements separated by spaces, or 'Empty'.",
                "constraints": "0 <= N, M <= 1000. Do not use memory allocation for the merged output aside from original setups.",
                "hints": "Leverage a dummy node implementation. Point to the smaller element from the two lists continually, and append any remaining nodes once one list exhausts.",
                "question_type": "CODING",
                "difficulty": "MEDIUM",
                "answer": "#include <stdio.h>\n#include <stdlib.h>\ntypedef struct Node { int d; struct Node* n; } Node;\nNode* create(int k) { if(k<=0) return NULL; Node *h=NULL, *t=NULL; while(k--) { int v; scanf(\"%d\", &v); Node* nn=malloc(sizeof(Node)); nn->d=v; nn->n=NULL; if(!h) h=t=nn; else { t->n=nn; t=nn; } } return h; }\nint main() {\n    int n, m; if(scanf(\"%d\", &n) != 1) return 0; Node* h1 = create(n);\n    if(scanf(\"%d\", &m) != 1) return 0; Node* h2 = create(m);\n    Node dummy; Node* tail = &dummy; dummy.n = NULL;\n    while(h1 && h2) { if(h1->d <= h2->d) { tail->n = h1; h1 = h1->n; } else { tail->n = h2; h2 = h2->n; } tail = tail->n; }\n    tail->n = h1 ? h1 : h2;\n    Node* t = dummy.n; if(!t) printf(\"Empty\\n\");\n    while(t) { printf(\"%d%c\", t->d, t->n?' ':'\\n'); t=t->n; }\n    return 0;\n}",
                "test_cases": [
                    {
                        "input": "3\n1 3 5\n3\n2 4 6",
                        "expectedOutput": "1 2 3 4 5 6"
                    },
                    {
                        "input": "2\n2 4\n4\n1 3 5 7",
                        "expectedOutput": "1 2 3 4 5 7"
                    },
                    {
                        "input": "0\n\n3\n10 20 30",
                        "expectedOutput": "10 20 30"
                    },
                    {
                        "input": "3\n1 1 1\n3\n1 1 1",
                        "expectedOutput": "1 1 1 1 1 1"
                    },
                    {
                        "input": "3\n10 20 30\n0",
                        "expectedOutput": "10 20 30"
                    },
                    {
                        "input": "0\n\n0",
                        "expectedOutput": "Empty"
                    },
                    {
                        "input": "1\n5\n1\n1",
                        "expectedOutput": "1 5"
                    },
                    {
                        "input": "4\n10 20 40 50\n2\n30 60",
                        "expectedOutput": "10 20 30 40 50 60"
                    }
                ],
                "solution_explanation": "A dummy node acts as a sturdy starting anchor, seamlessly preventing complex conditional checks for an empty merged head, merging the sorted chains strictly via referential pointer overrides.",
                "language": "C"
            },
            {
                "id": "w5-sll-004",
                "question_text": "Addition of Two Polynomials using Linked List",
                "question_description": "Polynomials can be structurally represented via traversing linked lists, whereby every node manages a specific polynomial coefficient and exponent. To combine algebraic outputs computationally, parse two mathematical polynomials into structured linked lists and execute valid mathematical addition. Exponents will be ordered in strictly decreasing sequence.",
                "input_format": "Integer N (terms in Poly 1), followed by N pairs of (coefficient, exponent).\nInteger M (terms in Poly 2), followed by M pairs of (coeff, exp).",
                "output_format": "The addition evaluation outputted synthetically as 'cx^e + cx^e...'. If result cleanly cancels, print '0'.",
                "constraints": "0 <= N, M <= 100. Coefficients dynamically merge. If resulting sum is 0 for an exponent, it mathematically drops output.",
                "hints": "Track simultaneously. If exponents equal, add coefficients. If one exp > other exp, inherit entirely from dominating side first and shift pointers downwards logically.",
                "question_type": "CODING",
                "difficulty": "HARD",
                "answer": "#include <stdio.h>\n#include <stdlib.h>\ntypedef struct Node { int c, e; struct Node* n; } Node;\nNode* create(int k) { Node *h=NULL, *t=NULL; while(k--) { int co, ex; scanf(\"%d %d\", &co, &ex); Node* nn=malloc(sizeof(Node)); nn->c=co; nn->e=ex; nn->n=NULL; if(!h) h=t=nn; else { t->n=nn; t=nn; } } return h; }\nint main() {\n    int n, m; if(scanf(\"%d\", &n)!=1) return 0; Node* p1 = create(n);\n    if(scanf(\"%d\", &m)!=1) return 0; Node* p2 = create(m);\n    Node d; Node* t = &d; d.n=NULL;\n    while(p1 && p2) { Node* nn = malloc(sizeof(Node)); nn->n=NULL; if(p1->e > p2->e) { nn->c = p1->c; nn->e = p1->e; p1=p1->n; } else if(p1->e < p2->e) { nn->c = p2->c; nn->e = p2->e; p2=p2->n; } else { nn->c = p1->c+p2->c; nn->e = p1->e; p1=p1->n; p2=p2->n; }\n        if(nn->c != 0) { t->n=nn; t=nn; } else free(nn); } \n    while(p1) { Node* nn=malloc(sizeof(Node)); *nn=*p1; nn->n=NULL; t->n=nn; t=nn; p1=p1->n; }\n    while(p2) { Node* nn=malloc(sizeof(Node)); *nn=*p2; nn->n=NULL; t->n=nn; t=nn; p2=p2->n; }\n    if(!d.n) { printf(\"0\\n\"); return 0; }\n    Node* x = d.n; while(x) { printf(\"%dx^%d%s\", x->c, x->e, x->n?\" + \":\"\"); x=x->n; } printf(\"\\n\"); return 0;\n}",
                "test_cases": [
                    {
                        "input": "3\n5 2 4 1 2 0\n3\n-5 2 3 1 1 0",
                        "expectedOutput": "7x^1 + 3x^0"
                    },
                    {
                        "input": "2\n3 3 2 1\n2\n4 2 1 0",
                        "expectedOutput": "3x^3 + 4x^2 + 2x^1 + 1x^0"
                    },
                    {
                        "input": "1\n5 2\n1\n-5 2",
                        "expectedOutput": "0"
                    },
                    {
                        "input": "0\n\n1\n6 4",
                        "expectedOutput": "6x^4"
                    },
                    {
                        "input": "2\n2 5 3 2\n3\n1 5 4 3 2 2",
                        "expectedOutput": "3x^5 + 4x^3 + 5x^2"
                    },
                    {
                        "input": "0\n\n0",
                        "expectedOutput": "0"
                    },
                    {
                        "input": "2\n10 10 5 5\n0",
                        "expectedOutput": "10x^10 + 5x^5"
                    },
                    {
                        "input": "1\n1 1\n1\n1 1",
                        "expectedOutput": "2x^1"
                    }
                ],
                "solution_explanation": "Iterative processing ensures standard linear mapping of polynomials. Dropping pairs identically netting a 0 coefficient maintains structurally sound polynomial standards without ghost variables padding memory.",
                "language": "C"
            }
        ]
    }
]