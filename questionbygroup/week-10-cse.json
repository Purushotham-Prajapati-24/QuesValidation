[
    {
        "name": "Week 10: Sorting Techniques",
        "questions": [
            {
                "id": "w10-sort-001",
                "question_text": "Merge Sort Implementation",
                "question_description": "Implement the **Merge Sort** algorithm to sort a given array of integers in ascending order. Observe how the array recursively divides at the midpoint and merges the subarrays back together in sorted order.",
                "input_format": "Integer N (size of array), followed by N space-separated integers.",
                "output_format": "The sorted sequence of N integers, single-spaced.",
                "constraints": "N <= 1000. Use standard integer typing. Handle an empty list without seg-faulting.",
                "hints": "Merge Sort recursively breaks down an array into halves until the units are single, then applies array tracking to cleanly merge the left and right sides without overlaps.",
                "question_type": "CODING",
                "difficulty": "MEDIUM",
                "answer": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid merge(int arr[], int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n    int L[n1], R[n2];\n    for (i = 0; i < n1; i++) L[i] = arr[l + i];\n    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];\n    i = 0; j = 0; k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) { arr[k] = L[i]; i++; }\n        else { arr[k] = R[j]; j++; }\n        k++;\n    }\n    while (i < n1) { arr[k] = L[i]; i++; k++; }\n    while (j < n2) { arr[k] = R[j]; j++; k++; }\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\nint main() {\n    int n;\n    if (scanf(\"%d\", &n) != 1) return 0;\n    if (n <= 0) { printf(\"\\n\"); return 0; }\n    int arr[n];\n    for(int i=0; i<n; i++) scanf(\"%d\", &arr[i]);\n    mergeSort(arr, 0, n - 1);\n    for(int i=0; i<n; i++) printf(\"%d%c\", arr[i], i==n-1 ? '\\n' : ' ');\n    return 0;\n}\n",
                "solution_explanation": "Merge sort guarantees O(N log N) functionality utilizing implicit tree partitioning. An extra array constructs linearly inside the merge block preventing variable overwriting during swaps.",
                "language": "C",
                "test_cases": [
                    {
                        "input": "5\n4 2 5 1 3",
                        "expectedOutput": "1 2 3 4 5"
                    },
                    {
                        "input": "3\n10 10 10",
                        "expectedOutput": "10 10 10"
                    },
                    {
                        "input": "1\n5",
                        "expectedOutput": "5"
                    },
                    {
                        "input": "0",
                        "expectedOutput": ""
                    },
                    {
                        "input": "4\n8 1 9 2",
                        "expectedOutput": "1 2 8 9"
                    },
                    {
                        "input": "6\n-1 -5 0 2 1 9",
                        "expectedOutput": "-5 -1 0 1 2 9"
                    },
                    {
                        "input": "5\n9 8 7 6 5",
                        "expectedOutput": "5 6 7 8 9"
                    },
                    {
                        "input": "5\n1 2 3 4 5",
                        "expectedOutput": "1 2 3 4 5"
                    },
                    {
                        "input": "2\n10 5",
                        "expectedOutput": "5 10"
                    },
                    {
                        "input": "7\n3 1 4 1 5 9 2",
                        "expectedOutput": "1 1 2 3 4 5 9"
                    }
                ]
            },
            {
                "id": "w10-sort-002",
                "question_text": "Heap Sort Implementation",
                "question_description": "Construct a sorting logic utilizing **Heap Sort**. Convert the unsorted array integers into a Max-Heap structure natively without linked memory, then continually extract limits downwards.",
                "input_format": "Integer N (size of array), followed by N space-separated integers.",
                "output_format": "The sorted sequence of N integers, single-spaced.",
                "constraints": "N <= 1000. Implement exactly using an array representation heap, O(1) auxiliary space.",
                "hints": "Identify the root limits applying 2*i + 1 (left child) and 2*i + 2 (right child). Maintain array indexes bounded to < n preventing out of bounds comparisons.",
                "question_type": "CODING",
                "difficulty": "HARD",
                "answer": "#include <stdio.h>\n\nvoid swap(int* a, int* b) { int t = *a; *a = *b; *b = t; }\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n    if (l < n && arr[l] > arr[largest]) largest = l;\n    if (r < n && arr[r] > arr[largest]) largest = r;\n    if (largest != i) {\n        swap(&arr[i], &arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);\n    for (int i = n - 1; i > 0; i--) {\n        swap(&arr[0], &arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\nint main() {\n    int n;\n    if (scanf(\"%d\", &n) != 1) return 0;\n    if (n <= 0) { printf(\"\\n\"); return 0; }\n    int arr[n];\n    for(int i=0; i<n; i++) scanf(\"%d\", &arr[i]);\n    heapSort(arr, n);\n    for(int i=0; i<n; i++) printf(\"%d%c\", arr[i], i==n-1 ? '\\n' : ' ');\n    return 0;\n}\n",
                "solution_explanation": "By reorganizing parent limits recursively against child pointers inside 'heapify', the array implicitly balances like a tree. Iterating extract ops natively results in a pure completely sorted collection.",
                "language": "C",
                "test_cases": [
                    {
                        "input": "5\n4 2 5 1 3",
                        "expectedOutput": "1 2 3 4 5"
                    },
                    {
                        "input": "3\n10 10 10",
                        "expectedOutput": "10 10 10"
                    },
                    {
                        "input": "1\n5",
                        "expectedOutput": "5"
                    },
                    {
                        "input": "0",
                        "expectedOutput": "\n"
                    },
                    {
                        "input": "4\n8 1 9 2",
                        "expectedOutput": "1 2 8 9"
                    },
                    {
                        "input": "6\n-1 -5 0 2 1 9",
                        "expectedOutput": "-5 -1 0 1 2 9"
                    },
                    {
                        "input": "5\n9 8 7 6 5",
                        "expectedOutput": "5 6 7 8 9"
                    },
                    {
                        "input": "5\n1 2 3 4 5",
                        "expectedOutput": "1 2 3 4 5"
                    },
                    {
                        "input": "2\n10 5",
                        "expectedOutput": "5 10"
                    },
                    {
                        "input": "7\n3 1 4 1 5 9 2",
                        "expectedOutput": "1 1 2 3 4 5 9"
                    }
                ]
            },
            {
                "id": "w10-sort-003",
                "question_text": "Quick Sort Implementation",
                "question_description": "Execute sorting applying standard recursive **Quick Sort**. Implement Lomuto partitioning treating the absolute highest indexed element as your central algorithm pivot.",
                "input_format": "Integer N (size of array), followed by N space-separated integers.",
                "output_format": "The sorted sequence of N integers, single-spaced.",
                "constraints": "N <= 1000. The array is updated directly inline with minimal swap overhead variables.",
                "hints": "During partition generation, iterate `j` toward the top bound swapping internal values below your selected pivot dynamically upwards.",
                "question_type": "CODING",
                "difficulty": "MEDIUM",
                "answer": "#include <stdio.h>\n\nvoid swap(int* a, int* b) { int t = *a; *a = *b; *b = t; }\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];  \n    int i = (low - 1);  \n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j] < pivot) {\n            i++;    \n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int n;\n    if (scanf(\"%d\", &n) != 1) return 0;\n    if (n <= 0) { printf(\"\\n\"); return 0; }\n    int arr[n];\n    for(int i=0; i<n; i++) scanf(\"%d\", &arr[i]);\n    quickSort(arr, 0, n - 1);\n    for(int i=0; i<n; i++) printf(\"%d%c\", arr[i], i==n-1 ? '\\n' : ' ');\n    return 0;\n}\n",
                "solution_explanation": "Quick sort achieves outstanding functional limits sorting variables completely in-place avoiding external buffer loops. Best case runs highly optimal O(N log N) relying exactly on intelligent partition boundaries.",
                "language": "C",
                "test_cases": [
                    {
                        "input": "5\n4 2 5 1 3",
                        "expectedOutput": "1 2 3 4 5"
                    },
                    {
                        "input": "3\n10 10 10",
                        "expectedOutput": "10 10 10"
                    },
                    {
                        "input": "1\n5",
                        "expectedOutput": "5"
                    },
                    {
                        "input": "0",
                        "expectedOutput": ""
                    },
                    {
                        "input": "4\n8 1 9 2",
                        "expectedOutput": "1 2 8 9"
                    },
                    {
                        "input": "6\n-1 -5 0 2 1 9",
                        "expectedOutput": "-5 -1 0 1 2 9"
                    },
                    {
                        "input": "5\n9 8 7 6 5",
                        "expectedOutput": "5 6 7 8 9"
                    },
                    {
                        "input": "5\n1 2 3 4 5",
                        "expectedOutput": "1 2 3 4 5"
                    },
                    {
                        "input": "2\n10 5",
                        "expectedOutput": "5 10"
                    },
                    {
                        "input": "7\n3 1 4 1 5 9 2",
                        "expectedOutput": "1 1 2 3 4 5 9"
                    }
                ]
            }
        ]
    }
]