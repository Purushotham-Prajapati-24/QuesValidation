[
    {
        "name": "Week - 6: Circular Linked List",
        "questions": [
            {
                "id": "w6-cll-001",
                "question_text": "Comprehensive Circular Linked List Operations",
                "question_description": "In this exercise, you must sequentially implement a Circular Singly Linked List utilizing dynamic memory. Unlike a standard list, the last node's 'next' pointer must strictly link back to the 'head' node, creating a complete circle. You must correctly manage insertions, deletions, and searching while dynamically updating the circular tail connection to maintain structural logic.",
                "input_format": "An integer N (number of operations), followed by N lines of commands:\n1. 'ins_beg X': Insert X at beginning.\n2. 'ins_end X': Insert X at end.\n3. 'ins_pos P X': Insert X at position P (1-based).\n4. 'del_beg': Delete from beginning.\n5. 'del_end': Delete from end.\n6. 'del_pos P': Delete node at position P.\n7. 'del_key X': Delete first occurrence of value X.\n8. 'display': Print all elements circularly from head.\n9. 'count': Print the number of nodes.\n10. 'search X': Find element X.",
                "output_format": "For deletions, print 'Underflow' if empty, or 'Not Found' if key doesn't exist. For 'search', print 'Found at P' or 'Not Found'. For 'display', print space-separated elements or 'Empty'.",
                "constraints": "1 <= N <= 1000. Use dynamic memory. The last node must perpetually point to the head.",
                "hints": "Maintain 'head' and optionally a 'tail' pointer for O(1) rear inserts. When deleting the only remaining node, strictly set head to NULL to avoid rogue circular references.",
                "question_type": "CODING",
                "difficulty": "MEDIUM",
                "answer": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\ntypedef struct Node { int d; struct Node* n; } Node;\nNode *head = NULL, *tail = NULL;\nvoid ib(int v) { Node* nn = malloc(sizeof(Node)); nn->d=v; if(!head) { head=tail=nn; nn->n=head; } else { nn->n=head; head=nn; tail->n=head; } }\nvoid ie(int v) { Node* nn = malloc(sizeof(Node)); nn->d=v; if(!head) { head=tail=nn; nn->n=head; } else { tail->n=nn; tail=nn; tail->n=head; } }\nvoid ip(int p, int v) { if(p==1) ib(v); else { Node* t=head; for(int i=1; i<p-1 && t!=tail; i++) t=t->n; Node* nn=malloc(sizeof(Node)); nn->d=v; nn->n=t->n; t->n=nn; if(t==tail) tail=nn; } }\nvoid db() { if(!head) printf(\"Underflow\\n\"); else if(head==tail) { free(head); head=tail=NULL; } else { Node* tmp=head; head=head->n; tail->n=head; free(tmp); } }\nvoid de() { if(!head) printf(\"Underflow\\n\"); else if(head==tail) { free(head); head=tail=NULL; } else { Node* t=head; while(t->n!=tail) t=t->n; free(tail); tail=t; tail->n=head; } }\nvoid dp(int p) { if(!head) printf(\"Underflow\\n\"); else if(p==1) db(); else { Node* t=head; for(int i=1; i<p-1 && t->n!=head; i++) t=t->n; if(t->n!=head) { Node* tmp=t->n; t->n=tmp->n; if(tmp==tail) tail=t; free(tmp); } } }\nvoid dk(int v) { if(!head) printf(\"Underflow\\n\"); else if(head->d==v) db(); else { Node* t=head; while(t->n!=head && t->n->d!=v) t=t->n; if(t->n!=head) { Node* tmp=t->n; t->n=tmp->n; if(tmp==tail) tail=t; free(tmp); } else printf(\"Not Found\\n\"); } }\nvoid disp() { if(!head) printf(\"Empty\\n\"); else { Node* t=head; do { printf(\"%d%c\", t->d, t==tail?'\\n':' '); t=t->n; } while(t!=head); } }\nvoid cnt() { if(!head) { printf(\"0\\n\"); return; } int c=0; Node* t=head; do { c++; t=t->n; } while(t!=head); printf(\"%d\\n\", c); }\nvoid sch(int v) { if(!head) { printf(\"Not Found\\n\"); return; } int p=1; Node* t=head; do { if(t->d==v) { printf(\"Found at %d\\n\", p); return; } p++; t=t->n; } while(t!=head); printf(\"Not Found\\n\"); }\nint main() {\n    int n, v, p; char op[15];\n    if(scanf(\"%d\", &n) != 1) return 0;\n    while(n--) {\n        scanf(\"%s\", op);\n        if(!strcmp(op, \"ins_beg\")) { scanf(\"%d\", &v); ib(v); }\n        else if(!strcmp(op, \"ins_end\")) { scanf(\"%d\", &v); ie(v); }\n        else if(!strcmp(op, \"ins_pos\")) { scanf(\"%d %d\", &p, &v); ip(p, v); }\n        else if(!strcmp(op, \"del_beg\")) db();\n        else if(!strcmp(op, \"del_end\")) de();\n        else if(!strcmp(op, \"del_pos\")) { scanf(\"%d\", &p); dp(p); }\n        else if(!strcmp(op, \"del_key\")) { scanf(\"%d\", &v); dk(v); }\n        else if(!strcmp(op, \"display\")) disp();\n        else if(!strcmp(op, \"count\")) cnt();\n        else if(!strcmp(op, \"search\")) { scanf(\"%d\", &v); sch(v); }\n    }\n    return 0;\n}",
                "test_cases": [
                    {
                        "input": "8\nins_end 10\nins_beg 5\nins_end 20\ncount\ndisplay\nsearch 10\ndel_pos 2\ndisplay",
                        "expectedOutput": "3\n5 10 20\nFound at 2\n5 20"
                    },
                    {
                        "input": "4\ndisplay\ndel_beg\ndel_end\ndel_key 10",
                        "expectedOutput": "Empty\nUnderflow\nUnderflow\nUnderflow"
                    },
                    {
                        "input": "5\nins_end 1\nins_end 2\nins_end 3\ndel_key 4\ndisplay",
                        "expectedOutput": "Not Found\n1 2 3"
                    },
                    {
                        "input": "5\nins_beg 100\nins_pos 2 200\nins_pos 1 50\ndisplay\ncount",
                        "expectedOutput": "50 100 200\n3"
                    },
                    {
                        "input": "5\nins_beg 7\ndel_end\nsearch 7\ncount\ndisplay",
                        "expectedOutput": "Not Found\n0\nEmpty"
                    },
                    {
                        "input": "4\nins_end 20\ndel_pos 1\ndisplay\ndel_pos 1",
                        "expectedOutput": "Empty\nUnderflow"
                    },
                    {
                        "input": "6\nins_end 5\nins_end 5\nins_end 5\ndel_key 5\ncount\ndisplay",
                        "expectedOutput": "2\n5 5"
                    },
                    {
                        "input": "3\nins_end 99\nsearch 99\nsearch 100",
                        "expectedOutput": "Found at 1\nNot Found"
                    },
                    {
                        "input": "7\nins_end 10\nins_end 20\nins_end 30\ndel_pos 2\ndisplay\ndel_pos 2\ndisplay",
                        "expectedOutput": "10 30\n10"
                    },
                    {
                        "input": "3\nins_beg 50\ndel_key 50\ndisplay",
                        "expectedOutput": "Empty"
                    }
                ],
                "solution_explanation": "A Circular Linked List replaces the standard NULL terminating condition with a loop back to the head. Traversal uses `do...while` loops comparing against the head pointer instead of checking for NULL to prevent infinite loops, and `tail->next` must actively update on every insertion/deletion at boundaries.",
                "language": "C"
            },
            {
                "id": "w6-cll-002",
                "question_text": "Check if a given Linked List is Circular",
                "question_description": "System architecture often breaks down due to rogue loops in what were meant to be strictly linear pathways. You are provided with a connected sequence. To guarantee a sequence is intentionally Circular, its final accessible node must strictly point completely back to its starting head position, rather than terminating randomly entirely or looping inwards upon a middle node.",
                "input_format": "An integer N, followed by N space-separated integers representing the list. A final integer C indicates the structure: 1 means circularly link the last node to the head, 0 means terminate with NULL.",
                "output_format": "Print 'Circular' if the structure loops back to the head natively, otherwise print 'Not Circular'.",
                "constraints": "0 <= N <= 1000.",
                "hints": "Traverse the sequence safely. If the pointer hits NULL, it is completely perfectly linear (Not Circular). If the pointer loops precisely back to exactly the Head node, it is Circular.",
                "question_type": "CODING",
                "difficulty": "EASY",
                "answer": "#include <stdio.h>\n#include <stdlib.h>\ntypedef struct Node { int d; struct Node* n; } Node;\nint main() {\n    int n; if(scanf(\"%d\", &n) != 1) return 0;\n    Node *h=NULL, *t=NULL; \n    for(int i=0; i<n; i++) {\n        int v; scanf(\"%d\", &v); Node* nn=malloc(sizeof(Node)); nn->d=v; nn->n=NULL;\n        if(!h) h=t=nn; else { t->n=nn; t=nn; }\n    }\n    int is_circ; if(scanf(\"%d\", &is_circ) == 1 && n > 0 && is_circ == 1) t->n = h;\n    if(!h) { printf(\"Not Circular\\n\"); return 0; }\n    Node* curr = h->n; \n    while(curr && curr != h) curr = curr->n;\n    if(curr == h) printf(\"Circular\\n\");\n    else printf(\"Not Circular\\n\");\n    return 0;\n}",
                "test_cases": [
                    {
                        "input": "5\n10 20 30 40 50\n1",
                        "expectedOutput": "Circular"
                    },
                    {
                        "input": "4\n1 2 3 4\n0",
                        "expectedOutput": "Not Circular"
                    },
                    {
                        "input": "1\n99\n1",
                        "expectedOutput": "Circular"
                    },
                    {
                        "input": "1\n10\n0",
                        "expectedOutput": "Not Circular"
                    },
                    {
                        "input": "3\n5 5 5\n1",
                        "expectedOutput": "Circular"
                    },
                    {
                        "input": "6\n1 3 5 7 9 11\n0",
                        "expectedOutput": "Not Circular"
                    },
                    {
                        "input": "2\n10 20\n1",
                        "expectedOutput": "Circular"
                    },
                    {
                        "input": "10\n1 2 3 4 5 6 7 8 9 10\n0",
                        "expectedOutput": "Not Circular"
                    },
                    {
                        "input": "0\n0",
                        "expectedOutput": "Not Circular"
                    },
                    {
                        "input": "3\n100 200 300\n0",
                        "expectedOutput": "Not Circular"
                    }
                ],
                "solution_explanation": "Validating circularity requires distinct logic. Rather than checking for mathematical cycle algorithms (like Floyd's), checking true full circularity solely entails verifying if the final traversal strictly collides organically back to the exact initial head memory reference.",
                "language": "C"
            }
        ]
    }
]