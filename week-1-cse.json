[
    {
        "name": "Week - 1: Stacks",
        "questions": [
            {
                "id": "w1-stack-001",
                "question_text": "Implementation of Stack using an array",
                "question_description": "In this foundational exercise, you are required to implement a fixed-size Stack data structure using an array of size 100. Your program must manage the Last-In-First-Out (LIFO) logic by implementing the core operations directly. You need to maintain a 'top' pointer and handle cases where the stack becomes empty or reaches its maximum capacity.",
                "input_format": "An integer N (number of operations), followed by N lines of commands:\n1. 'push X': Add integer X to the stack.\n2. 'pop': Remove and print the top element.\n3. 'peek': Print the top element without removing it.\n4. 'display': Print all elements from top to bottom.",
                "output_format": "For 'pop', print the value or 'Underflow'. For 'push', print 'Overflow' if full. For 'peek', print the value or 'Empty'. For 'display', print elements separated by space or 'Empty'.",
                "constraints": "Array Capacity = 100. 1 <= N <= 200.",
                "hints": "Initialize 'top' at -1. Increment top for push, decrement for pop. Always check if top == -1 before popping.",
                "question_type": "CODING",
                "difficulty": "MEDIUM",
                "answer": "#include <stdio.h>\n#include <string.h>\nint main() {\n    int stack[100], top = -1, n, v; char op[10];\n    if(scanf(\"%d\", &n) != 1) return 0;\n    while(n--) {\n        scanf(\"%s\", op);\n        if(strcmp(op, \"push\") == 0) {\n            if(scanf(\"%d\", &v) == 1) {\n                if(top >= 99) printf(\"Overflow\\n\");\n                else stack[++top] = v;\n            }\n        } else if(strcmp(op, \"pop\") == 0) {\n            if(top < 0) printf(\"Underflow\\n\");\n            else printf(\"%d\\n\", stack[top--]);\n        } else if(strcmp(op, \"peek\") == 0) {\n            if(top < 0) printf(\"Empty\\n\");\n            else printf(\"%d\\n\", stack[top]);\n        } else if(strcmp(op, \"display\") == 0) {\n            if(top < 0) printf(\"Empty\\n\");\n            else { for(int i=top; i>=0; i--) printf(\"%d%c\", stack[i], i==0?'\\n':' '); }\n        }\n    }\n    return 0;\n}",
                "test_cases": [
                    {
                        "input": "4\npush 10\npush 20\npeek\npop",
                        "expectedOutput": "20\n20"
                    },
                    {
                        "input": "2\npop\npeek",
                        "expectedOutput": "Underflow\nEmpty"
                    },
                    {
                        "input": "3\npush 5\ndisplay\npop",
                        "expectedOutput": "5\n5"
                    },
                    {
                        "input": "1\ndisplay",
                        "expectedOutput": "Empty"
                    },
                    {
                        "input": "4\npush 1\npush 2\npush 3\ndisplay",
                        "expectedOutput": "3 2 1"
                    },
                    {
                        "input": "2\npush 100\npeek",
                        "expectedOutput": "100"
                    },
                    {
                        "input": "3\npush 7\npop\npop",
                        "expectedOutput": "7\nUnderflow"
                    },
                    {
                        "input": "2\npush 44\npop",
                        "expectedOutput": "44"
                    },
                    {
                        "input": "4\npush 1\npush 2\npop\ndisplay",
                        "expectedOutput": "2\n1"
                    },
                    {
                        "input": "3\npush 9\npeek\ndisplay",
                        "expectedOutput": "9\n9"
                    }
                ],
                "solution_explanation": "A direct stack implementation uses an array and a top index. The push operation increments the index, while pop and peek access the current index. Display iterates backwards from the top to the bottom.",
                "language": "C"
            },
            {
                "id": "w1-stack-002",
                "question_text": "Balanced Parentheses using Stack",
                "question_description": "You are building a validation module for a high-security text editor. To ensure code integrity, you must verify that parentheses '()' are correctly nested. You can solve this by 'pushing' every opening '(' encountered onto a stack. When you find a closing ')', you must 'pop' the stack to match the pair. If you attempt to pop an empty stack, or if the stack is not empty at the end of the line, the parentheses are not balanced.",
                "input_format": "A single string containing only '(' and ')'.",
                "output_format": "Print 'Balanced' if the string is valid, otherwise print 'Not Balanced'.",
                "constraints": "1 <= length of string <= 1000.",
                "hints": "A stack is the best data structure for this because it tracks the most recently opened symbol. Use a simple char array to simulate the stack.",
                "question_type": "CODING",
                "difficulty": "HARD",
                "answer": "#include <stdio.h>\nint main() {\n    char s[1001]; int top = -1, valid = 1;\n    if(scanf(\"%s\", s) != 1) return 0;\n    for(int i=0; s[i]; i++) {\n        if(s[i] == '(') top++;\n        else if(s[i] == ')') {\n            if(top < 0) { valid = 0; break; }\n            top--;\n        }\n    }\n    if(valid && top == -1) printf(\"Balanced\\n\");\n    else printf(\"Not Balanced\\n\");\n    return 0;\n}",
                "test_cases": [
                    {
                        "input": "(())",
                        "expectedOutput": "Balanced"
                    },
                    {
                        "input": "()()",
                        "expectedOutput": "Balanced"
                    },
                    {
                        "input": "(()",
                        "expectedOutput": "Not Balanced"
                    },
                    {
                        "input": "())",
                        "expectedOutput": "Not Balanced"
                    },
                    {
                        "input": "((()))",
                        "expectedOutput": "Balanced"
                    },
                    {
                        "input": ")(",
                        "expectedOutput": "Not Balanced"
                    },
                    {
                        "input": "((",
                        "expectedOutput": "Not Balanced"
                    },
                    {
                        "input": "()",
                        "expectedOutput": "Balanced"
                    },
                    {
                        "input": "(()())",
                        "expectedOutput": "Balanced"
                    },
                    {
                        "input": ")))",
                        "expectedOutput": "Not Balanced"
                    }
                ],
                "solution_explanation": "Each opening bracket represents a pending closing bracket. We push to record the opening and pop to fulfill the pair. A balanced string requires a perfectly empty stack after processing.",
                "language": "C"
            },
            {
                "id": "w1-stack-003",
                "question_text": "Program to find the reverse of a string using a stack",
                "question_description": "A secure communication channel has intercepted a scrambled transmission. Based on the protocol, the message was generated character by character and then 'pushed' into a storage stack. To read the intended message, you must 'pop' every character from the stack until it is empty. Effectively, you are taking a scrambled input string and using stack operations to reverse it.",
                "input_format": "A single string S without spaces.",
                "output_format": "The reversed string produced by the stack-based recovery.",
                "constraints": "1 <= length of S <= 1000.",
                "hints": "Loop through the string and push each character into the stack array. Then, use a second loop to pop the characters until the top reaches -1.",
                "question_type": "CODING",
                "difficulty": "EASY",
                "answer": "#include <stdio.h>\n#include <string.h>\nint main() {\n    char s[1001], stack[1001]; int top = -1;\n    if(scanf(\"%s\", s) == 1) {\n        for(int i=0; s[i]; i++) stack[++top] = s[i];\n        while(top >= 0) printf(\"%c\", stack[top--]);\n        printf(\"\\n\");\n    }\n    return 0;\n}",
                "test_cases": [
                    {
                        "input": "hello",
                        "expectedOutput": "olleh"
                    },
                    {
                        "input": "stack",
                        "expectedOutput": "kcats"
                    },
                    {
                        "input": "A",
                        "expectedOutput": "A"
                    },
                    {
                        "input": "12345",
                        "expectedOutput": "54321"
                    },
                    {
                        "input": "radar",
                        "expectedOutput": "radar"
                    },
                    {
                        "input": "world",
                        "expectedOutput": "dlrow"
                    },
                    {
                        "input": "India",
                        "expectedOutput": "aidnI"
                    },
                    {
                        "input": "logic",
                        "expectedOutput": "cigol"
                    },
                    {
                        "input": "reverse",
                        "expectedOutput": "esrever"
                    },
                    {
                        "input": "data",
                        "expectedOutput": "atad"
                    }
                ],
                "solution_explanation": "Due to the LIFO (Last-In, First-Out) nature of a stack, the last character pushed is the first one retrieved (popped), which naturally results in the reversal of the sequence.",
                "language": "C"
            }
        ]
    }
]